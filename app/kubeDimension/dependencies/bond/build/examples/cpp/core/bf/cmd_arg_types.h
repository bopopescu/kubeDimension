
//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : Bond Compiler 0.3.0.5
//   File : cmd_arg_types.h
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once

#include <bond/core/bond_version.h>

#if BOND_VERSION < 0x302
#error This file was generated by a newer version of Bond compiler
#error and is incompatible with your version Bond library.
#endif

#if BOND_MIN_CODEGEN_VERSION > 0x0305
#error This file was generated by an older version of Bond compiler
#error and is incompatible with your version Bond library.
#endif

#include <bond/core/config.h>
#include <bond/core/containers.h>



namespace bf
{
    
    namespace _bond_enumerators
    {
    namespace Protocol
    {
        enum Protocol
        {
            guess,
            marshal,
            compact,
            compact2,
            fast,
            simple,
            simple2,
            json
        };
        
        extern const std::map<enum Protocol, std::string> _value_to_name_Protocol;
        extern const std::map<std::string, enum Protocol> _name_to_value_Protocol;

        inline
        const char* GetTypeName(enum Protocol)
        {
            return "Protocol";
        }

        inline
        const char* GetTypeName(enum Protocol, const bond::qualified_name_tag&)
        {
            return "bf.Protocol";
        }

        inline
        const std::map<enum Protocol, std::string>& GetValueToNameMap(enum Protocol)
        {
            return _value_to_name_Protocol;
        }

        inline
        const std::map<std::string, enum Protocol>& GetNameToValueMap(enum Protocol)
        {
            return _name_to_value_Protocol;
        }

        const std::string& ToString(enum Protocol value);

        void FromString(const std::string& name, enum Protocol& value);

        inline
        bool ToEnum(enum Protocol& value, const std::string& name)
        {
            std::map<std::string, enum Protocol>::const_iterator it =
                _name_to_value_Protocol.find(name);

            if (_name_to_value_Protocol.end() == it)
                return false;

            value = it->second;

            return true;
        }
    } // namespace Protocol
    } // namespace _bond_enumerators

    using namespace _bond_enumerators::Protocol;
    

    
    struct Options
    {
        bool help;
        std::string output;
        ::bf::Protocol from;
        ::bf::Protocol to;
        bool all_fields;
        std::string schema;
        std::string file;
        
        Options()
          : help(),
            output("stdout"),
            from(::bf::_bond_enumerators::Protocol::guess),
            to(::bf::_bond_enumerators::Protocol::json),
            all_fields()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        Options(const Options& other) = default;
#endif
        
#ifndef BOND_NO_CXX11_RVALUE_REFERENCES
        Options(Options&& other)
          : help(std::move(other.help)),
            output(std::move(other.output)),
            from(std::move(other.from)),
            to(std::move(other.to)),
            all_fields(std::move(other.all_fields)),
            schema(std::move(other.schema)),
            file(std::move(other.file))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        Options& operator=(const Options& other) = default;
#endif

        bool operator==(const Options& other) const
        {
            return true
                && (help == other.help)
                && (output == other.output)
                && (from == other.from)
                && (to == other.to)
                && (all_fields == other.all_fields)
                && (schema == other.schema)
                && (file == other.file);
        }

        bool operator!=(const Options& other) const
        {
            return !(*this == other);
        }

        void swap(Options& other)
        {
            using std::swap;
            swap(help, other.help);
            swap(output, other.output);
            swap(from, other.from);
            swap(to, other.to);
            swap(all_fields, other.all_fields);
            swap(schema, other.schema);
            swap(file, other.file);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(Options& left, Options& right)
    {
        left.swap(right);
    }
} // namespace bf

